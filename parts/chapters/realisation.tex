\chapter{Réalisation}
% l’ordre de présentation le plus logique est souvent l’ordre chronologique dans lequel les tâches ont été accomplies. Il faut présenter les points forts en distinguant nettement l’existant et la plus-value apportée par le stagiaire. Si des solutions ont été envisagées, mais non retenues, il peut être intéressant de les présenter en expliquant pourquoi elles ont été abandonnées. C’est toute la chaîne, de la prise de connaissance du problème à la solution apportée, qui doit être déroulée.

% Cette partie débouche nécessairement sur des résultats qu’il faut énoncer en précisant leurs exploitations actuelles ou à venir. Il faut annoncer clairement ce qui a été réalisé ou non par rapport à la mission de départ. Cette partie peut être complétée par des propositions personnelles du stagiaire pour prolonger son travail, et même par des critiques positives de son environnement de travail.

% Tentative plan
%5.1. recherche doc
%5.2. patch "reimplement"
%5.3. build "growing"
%5.4. optimise "growing"
%5.5. conclusions on "growing" and "awd"
%5.6. preparing "papud" \& basic model
%5.7. understanding strange comportment \& preparing corpus
%5.8. conclusions on "papud"

\section{\Glsentrytext{project_gmsnn}} % TODO nommer ce projet
\input{parts/chapters/realisation/gmsnn/doc} % lib, tutos, concepts
\input{parts/chapters/realisation/gmsnn/reimplement} % reprise sur de l'existant, découverte de la lib
\input{parts/chapters/realisation/gmsnn/begin_gmsnn} % reprise sur de l'existant
\input{parts/chapters/realisation/gmsnn/optimise_gmsnn} % Optimisation et amélioration du nouveau modèle
\input{parts/chapters/realisation/gmsnn/examples_production}
\input{parts/chapters/realisation/gmsnn/white_flag}
\subsection{Conclusions}
% TODO production des résultats -> nospace
Ce projet nous à permit d'implémenter une architecture innovante de \gls{nn}, à partir d'un modèle état de l'art.

% ccl plus pb mémoire & tps, opti z'oignons (XD) même, 5 min c'est balèze
C'est la première pierre de l'édifice qu'est le \gls{gmsnn}.
mise en œuvre de l'architecture proposée. La dernière étape est d'améliorer les performances du modèle, et de l'optimiser.
Cette partie du \gls{project_gmsnn} à permit d'améliorer notablement les performances du \gls{model}, tout en réduisant drastiquement le coût d'entraînement.

De plus, l'algorithme présenté \autoref{subsec:optilbl} à démontré une faiblesse majeure de l'architecture \gls{gmsnn}.
La réalisation de ce projet nous à permit d'approfondir largement nos connaissances en \gls{dl}. 


\section{\Glsentrytext{project_papud}}
\subsection{Recherche documentaire} % lib, tutos, concepts
\subsection{Ré-implémentation simplifiée du modèle \glsentrytext{soa}} % reprise sur de l'existant, découverte de la lib
\subsection{Implémentation du nouveau modèle basique} % reprise sur de l'existant
\subsection{Optimisation et amélioration du nouveau modèle}
\subsection{Conclusions}


\section{Documentation}


%Il est aisé d'insérer du code dans un rapport. Il suffit de définir le langage, la légende à afficher et enfin un Label pour pouvoir y faire référence. Le résultat est donnée dans le listing \ref{lst:premierExemple}. Il est également possible de changer les couleurs, pour cela il faut éditer le lstset dans la classe tnreport.cls.

%\begin{lstlisting}[language=c++, caption={Premier Exemple}, label={lst:premierExemple}]
%void CEquation::IniParser()
%{
%if (!pP){ //if not already initialized...
%pP = new mu::Parser;
%
%pP->DefineOprt("%", CEquation::Mod, 6); //deprecated
%pP->DefineFun("mod", &CEquation::Mod, false);
%pP->DefineOprt("&", AND, 1); //DEPRECATED
%pP->DefineOprt("and", AND, 1);
%pP->DefineOprt("|", OR, 1); //DEPRECATED
%pP->DefineOprt("or", OR, 1);
%pP->DefineOprt("xor", XOR, 1);
%pP->DefineInfixOprt("!", NOT);
%pP->DefineFun("floor", &CEquation::Floor, false);
%pP->DefineFun("ceil", &CEquation::Ceil, false);
%pP->DefineFun("abs", &CEquation::Abs, false);
%pP->DefineFun("rand", &CEquation::Rand, false);
%pP->DefineFun("tex", &CEquation::Tex, false);
%
%pP->DefineVar("x", &XVar);
%pP->DefineVar("y", &YVar);
%pP->DefineVar("z", &ZVar);
%}
%}
%\end{lstlisting}
%\clearpage
%Il est également possible d'afficher du code directement depuis un fichier source, le résultat de cette opération est visible dans le listing \ref{lst:fromSrc}
%\lstinputlisting[language=c++,caption={Affichage depuis le fichier source},label={lst:fromSrc}]{figures/sourceCode.cpp}